# table_package_praktikum3

<h1>Задачи для третьего задания Практикума по программированию. Общая тема задания «реализация собственного пакета модулей по манипулированию табличными данными».</h1>

Базовая часть (выполняется всеми самостоятельно!):<br>
На базе модулей: csv, pickle и прямой работы с файлами реализовать следующий базовый функционал:<br>
•	функций load_table, save_table по загрузке/сохранению табличных данных во внутреннее представление модуля/из внутреннего представления модуля:<br>
o	файла формата csv (отдельный модуль с load_table, save_table в рамках общего пакета)<br>
o	файла формата pickle (отдельный модуль с load_table, save_table в рамках общего пакета), модуль использует структуру данных для представления таблицу, удобную автору работы.<br>
o	текстового файла (только функция save_table сохраняющая в текстовом файле представление таблицы, аналогичное выводу на печать с помощью функции print_table()).<br>
Примечание: внутреннее представление может базироваться на словаре, где по разным ключам хранятся ключевые «атрибуты» таблицы, <br>а значения таблицы хранятся в виде вложенных списков. Студент может выбрать другое внутреннее представление таблицы <br>(согласовав его с преподавателем), в том числе, <br>студенты знакомые с ООП на Python, могут реализовать собственный класс для таблицы.<br>
При определении api модулей максимально полно использовать возможности сигнатур функций на Python <br>(значения по умолчанию, запаковка/распаковка, в т.ч. именованных параметров, возвращение множественных значений), <br>интенсивно выполнять проверки и возбуждать исключительные ситуации.<br>

•	модуля с базовыми операциями над таблицами:<br>
!	get_rows_by_number(start, [stop], copy_table=False) – получение таблицы из одной строки или из строк из интервала по номеру строки. <br>Функция либо копирует исходные данные, либо создает новое представление таблицы, работающее с исходным набором данных (copy_table=False),<br> таким образом изменения, внесенные через это представления будут наблюдаться и в исходной таблице.<br>
!	get_rows_by_index(val1, … , copy_table=False) – получение новой таблицы из одной строки или из строк со значениями в первом столбце,<br> совпадающими с переданными аргументами val1, … , valN. Функция либо копирует исходные данные, либо создает новое представление таблицы,<br> работающее с исходным набором данных (copy_table=False), таким образом изменения, внесенные через это представления будут наблюдаться и в исходной таблице.<br>
!	get_column_types(by_number=True) – получение словаря вида столбец:тип_значений. Тип значения: int, float, bool, str (по умолчанию для всех столбцов). Параметр by_number определяет вид значения столбец – целочисленный индекс столбца или его строковое представление.
!	set_column_types(types_dict, by_number=True) – задание словаря вида столбец:тип_значений. Тип значения: int, float, bool, str (по умолчанию для всех столбцов). Параметр by_number определяет вид значения столбец – целочисленный индекс столбца или его строковое представление.
!	get_values(column=0) – получение списка значений (типизированных согласно типу столбца) таблицы из столбца либо по номеру столбца (целое число, значение по умолчанию 0, либо по имени столбца)
!	get_value(column=0) – аналог get_values(column=0) для представления таблицы с одной строкой, возвращает не список, а одно значение (типизированное согласно типу столбца).
!	set_values(values, column=0) – задание списка значений values для столбца таблицы (типизированных согласно типу столбца) либо по номеру столбца (целое число, значение по умолчанию 0, либо по имени столбца).
!	set_value(column=0) – аналог set_values(value, column=0) для представления таблицы с одной строкой, устанавливает не список значений, а одно значение (типизированное согласно типу столбца).
!	print_table() – вывод таблицы на печать.<br>
•	Для каждой функции должно быть реализована генерация не менее одного вида исключительных ситуаций. 

<h2>7)По аналогии с п. 6 реализовать функции eq (==), gr (>), ls (<), ge (>=), le (<=), ne (==), которые возвращают список булевских значений длинной в количество строк сравниваемых столбцов. Реализовать функцию filter_rows (bool_list, copy_table=False) – получение новой таблицы из строк для которых в bool_list (длинной в количество строк в таблице) находится значение True.
Сложность 3</h2>


